//STD Headers
#include <cstddef>
#include <array>

//Library Headers
#include "gtest/gtest.h"

//Void Engine Headers
#include "utils/reflection/TypeInfo.h"

namespace rttr_test {
	CLASS()
		class User {
		public:
			PROPERTY()
			int m_ID;

			PROPERTY()
			double m_Money;

			CTOR()
			User() {
				m_ID = 0;
				m_Money = 0;
				m_PrivateProperty = 0;
			}

			FUNCTION()
			bool Modify() {
				m_ID++;
			}

		private:
			int m_PrivateProperty;
	};
}

// Sample reflection data format, to be generated by VoidReflect
namespace utils {
	//Types discovered by reflection
	IMPL_GET_TYPE(rttr_test::User)

	//Implementations of class reflection for types discovered
	template<>
	const Class& utils::GetClass<rttr_test::User>() {
		static std::array<Property, 2> properties{
			Property {
				GetType<int>(),
				"m_ID",
				offsetof(rttr_test::User, m_ID)
			},
			Property {
				GetType<double>(),
				"m_Money",
				offsetof(rttr_test::User, m_Money)
			}
		};
		
		static std::array<Function, 0> funcs;
			
		static ClassData<2, 0> dataCache(
			properties,
			funcs
		);
		
		static Class classDescriptor{
			GetType<rttr_test::User>(),
			dataCache
		};

		return classDescriptor;
	}
}

using namespace utils;

namespace utils_tests {
	
	TEST(RTTR_Tests, PrimitiveReflectionTest) {
		auto intRefl = GetType<int>();
		ASSERT_EQ(intRefl.m_Name, utils::Name("int"));
		ASSERT_EQ(intRefl.m_Size, sizeof(int));

		auto doubleRefl = GetType<double>();
		ASSERT_EQ(doubleRefl.m_Name, utils::Name("double"));
		ASSERT_EQ(doubleRefl.m_Size, sizeof(double));
		
		auto boolRefl = GetType<bool>();
		ASSERT_EQ(boolRefl.m_Name, utils::Name("bool"));
		ASSERT_EQ(boolRefl.m_Size, sizeof(bool));
	}

	TEST(RTTR_Tests, ClassPropertyAccessTest) {
		rttr_test::User instance;

		auto userRefl = GetClass<rttr_test::User>();
		ASSERT_EQ(2, userRefl.m_Data.Properties().size());

		instance.m_ID = 0;
		userRefl.SetProperty(&instance, utils::Name("m_ID"), 12345);
		ASSERT_EQ(12345, instance.m_ID);

		instance.m_ID = 123456;
		int id = userRefl.GetProperty<int>(&instance, utils::Name("m_ID")).value();
		ASSERT_EQ(123456, id);
	}

}
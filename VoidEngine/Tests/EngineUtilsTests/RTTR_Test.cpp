//STD Headers
#include <cstddef>
#include <array>

//Library Headers
#include "gtest/gtest.h"

//Void Engine Headers
#include "utils/reflection/Reflection.h"

namespace rttr_test {
	CLASS()
	class User {
		public:
			PROPERTY()
			int m_ID;

			PROPERTY()
			double m_Money;

			CTOR()
			User() {
				m_ID = 0;
				m_Money = 0;
				m_PrivateProperty = 0;
			}

			FUNCTION()
			virtual bool Modify() {
				m_ID++;
				return true;
			}

		private:
			int m_PrivateProperty;
	};

	class Player : public User {
	public:
		PROPERTY()
		int m_XP;

		CTOR()
		Player() {
			m_XP = 0;
		}
	private:
		FUNCTION()
		bool Modify() override {
			m_XP++;
			m_Money += 1.0;
			return true;
		}

		FUNCTION()
		int GainXP(int amount) {
			m_XP += amount;
		}
	};
}

// Sample reflection data format, to be generated by VoidReflect
namespace utils {
	//Types discovered by reflection
	IMPL_GET_TYPE(rttr_test::User)
	IMPL_GET_TYPE(rttr_test::Player)

	//Implementations of class reflection for types discovered
	template<>
	const ClassDescriptor& utils::reflection::GetClass<rttr_test::User>() {
		static std::array<Property, 2> properties{
			Property {
				GetType<int>(),
				"m_ID",
				offsetof(rttr_test::User, m_ID)
			},
			Property {
				GetType<double>(),
				"m_Money",
				offsetof(rttr_test::User, m_Money)
			}
		};

		static std::array<Function, 0> funcs;

		static ClassData<2, 0, 0> dataCache(
			properties,
			funcs
		);

		static ClassDescriptor classDescriptor{
			GetType<rttr_test::User>(),
			dataCache
		};

		return classDescriptor;
	}

	template<>
	const ClassDescriptor& utils::reflection::GetClass<rttr_test::Player>() {
		static std::array<Property, 1> properties{
			Property {
				GetType<int>(),
				"m_XP",
				offsetof(rttr_test::Player, m_XP)
			}
		};

		static std::array<const ClassDescriptor*, 1> parents{
			&GetClass<rttr_test::User>()
		};

		static std::array<Function, 0> funcs;

		static ClassData<1, 0, 1> dataCache(
			properties,
			funcs,
			parents
		);

		static ClassDescriptor classDescriptor{
			GetType<rttr_test::Player>(),
			dataCache
		};

		return classDescriptor;
	}
}

using namespace utils;

namespace utils_tests {
	
	TEST(RTTR_Tests, PrimitiveReflectionTest) {
		auto intRefl = reflection::GetType<int>();
		ASSERT_EQ(intRefl.m_Name, utils::Name("int"));
		ASSERT_EQ(intRefl.m_Size, sizeof(int));

		auto doubleRefl = reflection::GetType<double>();
		ASSERT_EQ(doubleRefl.m_Name, utils::Name("double"));
		ASSERT_EQ(doubleRefl.m_Size, sizeof(double));
		
		auto boolRefl = reflection::GetType<bool>();
		ASSERT_EQ(boolRefl.m_Name, utils::Name("bool"));
		ASSERT_EQ(boolRefl.m_Size, sizeof(bool));
	}

	TEST(RTTR_Tests, ClassDescriptorPropertyCountTest) {
		auto userRefl = reflection::GetClass<rttr_test::User>();
		auto playerRefl = reflection::GetClass<rttr_test::Player>();

		ASSERT_EQ(2, userRefl.GetPropertyCount());
		ASSERT_EQ(3, playerRefl.GetPropertyCount());
	}

	TEST(RTTR_Tests, ClassDescriptorPropertyReflectionAccessTest) {
		//Base class reflection
		auto userRefl = reflection::GetClass<rttr_test::User>();
		auto userProps = userRefl.GetProperties();
		ASSERT_EQ(userRefl.GetPropertyCount(), userProps.size());
		
		auto idProp = userRefl.GetProperty(utils::Name("m_ID"));
		ASSERT_EQ(true, idProp.has_value());
		ASSERT_EQ("m_ID", idProp.value().m_Name);

		//Derived class reflection
		auto playerRefl = reflection::GetClass<rttr_test::Player>();
		auto playerProps = playerRefl.GetProperties();
		ASSERT_EQ(playerRefl.GetPropertyCount(), playerProps.size());
		ASSERT_EQ("m_ID", userRefl.GetProperty(utils::Name("m_ID")).value().m_Name);
	}

	TEST(RTTR_Tests, ClassDescriptorPropertyDataAccessTest) {
		rttr_test::User instance;

		auto userRefl = reflection::GetClass<rttr_test::User>();
		ASSERT_EQ(2, userRefl.GetPropertyCount());

		instance.m_ID = 0;
		userRefl.SetPropertyData(&instance, utils::Name("m_ID"), 12345);
		ASSERT_EQ(12345, instance.m_ID);

		instance.m_ID = 123456;
		int id = userRefl.GetPropertyData<int>(&instance, utils::Name("m_ID")).value();
		ASSERT_EQ(123456, id);

		//Polymorphic class data access dest
		std::unique_ptr<rttr_test::User> polyInstance = std::make_unique<rttr_test::Player>();
		auto playerRefl = reflection::GetClass<rttr_test::Player>();

		polyInstance->m_ID = 1234;
		auto playerID = playerRefl.GetPropertyData<int>(polyInstance.get(), utils::Name("m_ID"));
		ASSERT_EQ(1234, playerID);
		
		playerRefl.SetPropertyData(polyInstance.get(), utils::Name("m_ID"), 1);
		ASSERT_EQ(1, polyInstance->m_ID);

		dynamic_cast<rttr_test::Player*>(polyInstance.get())->m_XP = 1337;
		auto xpVal = playerRefl.GetPropertyData<int>(polyInstance.get(), utils::Name("m_XP"));
		ASSERT_EQ(true, xpVal.has_value());
		ASSERT_EQ(1337, xpVal.value());

		playerRefl.SetPropertyData<int>(polyInstance.get(), utils::Name("m_XP"), 0);
		ASSERT_EQ(0, dynamic_cast<rttr_test::Player*>(polyInstance.get())->m_XP);
	}
}